# Забор картинок с поливижена :O
Тестовый бот живет на **@N8N_hueta_btw_bot**
(Проживет один день и умрет)
В репе лежит файлик с которого поднят бот
## Дисклеймер
**На этот прекрасный материал ушло в 3 раза больше времени чем на бота, бот рожден в говне и должен быть говном:)**
## Импорт библиотек
```python3
import telebot
import urllib.request
```
*import* - обращение к библиотеке
- **telebot** - для взаимодействия с ботом через **API**
- **request** - для забора картинки с камеры
*telebot* - не входит в стандартный пакет поставки Python, поэтому предварительно его нужно скачать:
```bash
pip3 install pyTelegramBotAPI
```
 Если нет **python/pip**, ставим **3-ю** версию, бо мы же адекватные люди:
```bash
apt install python3
apt install python3-pip
```
## Подключаем бота
 Для начала нужно создать бота, через **@BotFather** в самом телеграмм, от него нам требуется лишь **Token** вида:
```Telegram
000000000:KfndnsarY-xt_JfNyzFNuu3rzuya33B7042g
```
Теперь создаем переменную, в которой будем хранить бота и через **Telebot** получаем атрибуты объекта:
```python
TOKEN = '000000000:KfndnsarY-xt_JfNyzFNuu3rzuya33B7042g'
#В Python нет констант, токен у нас неизменен, поэтому хорошим тоном считается все же обозначить его через переменную с именем в верхнем регистре
bot = telebot.TeleBot(TOKEN)
```
 В дефолте, у бота есть два варианта прослушки сообщений, через хук или же заставляем бота самого слушать телеграмм и ждать ~~прилета~~прихода сообщений. 
  Наш путь второй, ибо первый требует доступа извне к вашей машине, а мы бедные и делаем на коленке, поэтому добавляем:
```python
bot.polling()
```
 В конец кода/рабочей функции.

## Получаем изображение
```python
def getimg():
#Через request считываем картинку по ссылке
	snapshot_address = 'http://10.0.0.10/webcapture.jpg?command=snap&channel=1'
    img = urllib.request.urlopen(snapshot_address).read()
#Задаем переменную вывода,
    out = open('pacanskiy_jpeg.jpg', 'wb')
#Собственно записываем само изображение и закрываем сеанс
    out.write(img)
    out.close
```
## Собственно бот
### Security(be like Anton)
 В моем варианте я еще прикрутил простенькую авторизацию, но дабы не растягивать материал, да и в целом кому не похрен на секурность, тем более что в телеграмм-ботах она позорная:
- Либо ты авторизуешься через проверку id отправителя - что, собственно обходится простым post-запросом с подменой
- Либо прикручиваешь сеансы с авторизацией к боту, что конечно круто, но реально лишнее в конкретном примере
### Клавиатура
 Один из самых приятных методов общения с ботом - инлайн клавиатуры, в нашем случае понадобиться всего одна с одной кнопкой:
```python
keyboard = telebot.types.InlineKeyboardMarkup()
keyboard.add(telebot.types.InlineKeyboardButton(text='НАДПИСЬ НА КНОПКЕ', callback_data='/НАЗВАНИЕ_КОМАНДЫ_ВОЗВРАТА'))
```
**keyboard** - объект сформированный библиотекой, через .add мы добавляем к нему кнопку, которая будет иметь **'НАДПИСЬ'** и возвращать **callback_data**
 Можно например добавить в клавиатуру сразу много кнопок, просто спамя .add
```python
kb = telebot.types.InlineKeyboardMarkup()
kb.add(telebot.types.InlineKeyboardButton(text='Я', callback_data='/i'))
kb = telebot.types.InlineKeyboardMarkup()
kb.add(telebot.types.InlineKeyboardButton(text='НЕНАВИЖУ', callback_data='/hate'))
kb = telebot.types.InlineKeyboardMarkup()
kb.add(telebot.types.InlineKeyboardButton(text='ПИВО', callback_data='/beer'))
```
 Про **callback_data** - немного позже. На этом с интерфейсом все))
### Hello ~~world~~
 Организуем обработку команды запуска бота **\/start**
```python
#Собственно сам декоратор, в commands - можно указать иную, свою команду
@bot.message_handler(commands=['start'])
#Теперь объявляем функцию связанную с декоратором, нигде задействовать ее не нужно
#она обработается при вызове команды /start
#Но если требуется, ее можно отдельно вызвать передав сообщение как аргумент функции
def start_message(message):
#Для работоспособности не требуется, но всем же нравится, когда с ними вежливы
#поэтому получаем имя отправителя и пихаем в переменную
    username = message.from_user.first_name
#Ну и собственно отвечаем на /start
#reply_to - процитирует предыдущее сообщение и ответит на него текстом/картинкой/ссылкой на твич 12ти летнего майнкрафтера
    bot.reply_to(message,f'Привет {username}!',reply_markup=keyboard)
```
 **f''** перед строковым значением позволяет внутри него использовать **переменную** , полученную раньше. Конечно никто не запрещает сотворить богомерзость:
``` python
sho = 'це европа'
print('украина'+sho+'!')
```
 Но мы же не из лесу вышли)
**reply_markup=keyboard** - вызывает заранее созданную нами клавиатуру под сообщением.
### Отправка 
 Создаем еще один декоратор и функцию, отвечающие на вызовы(**callback**):
``` python
@bot.callback_query_handler(func=lambda call: True)
def callback_inline(call):
#т.к. декоратор у нас с заделом на будущее, то используем условие
#Которое будет проверять соответствие вызова конкретной команде:
    if call.data == '/get':
#Вызываем ранее созданную функцию получения снапшота
        getimg()
#Открываем полученную фотографию и присваеваем переменной:
        photo = open('img.jpg', 'rb')
#Отправляем через бота полученное фото, ну и вызываем к нему все ту же клавиатуру:
        bot.send_photo(call.message.chat.id, photo, reply_markup=keyboard)
#Необязательно, но все же рекомендуемо, в случае несоответствия происходит НИЧЕГО(pass)
    else:
        pass
```
 Сохраняем весь наш прекрасный код в файлик с расширением **.py**, например **bot.py**
  И вызываем его
``` bash
python3 bot.py
```
# ВЫ ПРЕКРАСНЫ!
